# 切片的基本说明和使用

## 简介

go数组的长度不可变，切片则是可变长的动态数组。

## 基本说明

切片的2个重要部分：
* len：长度
* cap：容量

1. 长度和容量可以在定义切片时指定（也可不指定）
2. 长度不能超过容量，否则报错
3. 读切片只能在长度范围内，写切片只能在容量范围内，容量不足时可通过append方式追加元素

## 定义切片

### 定义
>> 事例的切片类型为string,可替换为任意类型

不指定大小
```
var s []string
```

指定长度。通过make来创建切片,必须指定长度（即切片的初始长度），容量可选
```
var s = make([]string, len) //不推荐

s := make([]string, len) //推荐
```

指定容量（make必须指定长度）
```
s := make([]string, len, cap)
```

### 举例说明

不指定大小
```
  var s []string

  //输出：len=0, cap=0
  fmt.Printf("len=%d, cap=%d\n", len(s), cap(s)) 

  //报错：下标越界。panic: runtime error: index out of range
  fmt.Printf("s[0]=%s\n", s[0]) 

  //报错：下标越界。panic: runtime error: index out of range
  //因为s为空切片，对空切片的下标操作均不允许，如s[0]本身就表示读取s的第一个元素
  s[0] = "a"
  fmt.Printf("s[0]=%s\n", s[0])

  //写空切片，需要通过append追加的方式
  //输出：len=1, cap=1, s=[a]
	s = append(s, "a")
	fmt.Printf("len=%d, cap=%d, ", len(s), cap(s))
	fmt.Printf("s=%s\n", s)
```
只声明但不指定大小的切片，不能对其进行下标操作，写切片只能通过append追加


指定长度和容量
```
//容量>长度
//静态编译通过，动态编译报错：len larger than cap in make([]string)
s := make([]string, 2, 1)
fmt.Printf("len=%d, cap=%d\n", len(s), cap(s))
```

## 初始化切片

通过make方式(cap可选)
```
s:=make([]string,len,cap)
```

直接初始化
```
s:=[]string{"1","2","3"} //len=cap=3
```

初始化切片，是已存在数组（或切片）的**引用**  
方式：
```
//将arr中从下标 start到**end-1** 下的元素创建为一个新的切片。
s := arr[start:end]

//缺省end：arr中下标从 start到len(arr)-1
s := arr[start:]

//缺省start：arr中下标从 0到end-1
s := arr[:end]

//缺省start和end：arr中下标从 0到len(arr)-1
s := arr[:]
```
**注意**：通过数组a（或切片）初始化切片b的方式，b其实是a某片段的引用，对b的修改将引起a的修改

```
//先定义一个数组
arr := [3]string{"1", "2", "3"} //或切片：[]string{"1", "2", "3"}

s := arr[:2]
fmt.Println(s) // [1 2]
s2[0] = "a"
fmt.Println(s2, s) // [a 2] [a 2 3]
```


